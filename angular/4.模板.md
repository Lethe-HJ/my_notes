## 插值语法

```html
<h3>1+1={{1+1}}</h3>
```

调用组件里面定义的方法：

```ts
<h3>可以调用方法{{getVal()}}</h3>

public getVal():any{
  return 65535;
}
```

### 模板内的局部变量

```html
<input #heroInput><p>{{heroInput.value}}</p>
```

如果模板里面定义的局部变量和组件内部的属性重名

Angular 会按照以下优先级来进行处理：

模板局部变量 > 指令中的同名变量 > 组件中的同名属性。

## 属性绑定

属性绑定是用方括号来做的，写法：

```html
<img [src]="imgSrc" />

public imgSrc:string="./assets/imgs/1.jpg";
```
这种绑定是单向的。

## 事件绑定

```html
<button class="btn btn-success" (click)="btnClick($event)">测试事件</button>
```

对应 Component 内部的方法定义：

```ts
public btnClick(event):void{
  alert("测试事件绑定！");}
```

### 使用 `EventEmitter` 实现自定义事件

指令使用 Angular EventEmitter 来触发自定义事件。 指令创建一个 `EventEmitter` 实例，并且把它作为属性暴露出来。 指令调用 `EventEmitter.emit(payload)` 来触发事件，可以传入任何东西作为消息载荷。 父指令通过绑定到这个属性来监听事件，并通过 `$event` 对象来访问载荷。

假设 `ItemDetailComponent` 用于显示英雄的信息，并响应用户的动作。 虽然 `ItemDetailComponent` 包含删除按钮，但它自己并不知道该如何删除这个英雄。 最好的做法是触发事件来报告“删除用户”的请求。

下面的代码节选自 `ItemDetailComponent`：ts

src/app/item-detail/item-detail.component.html (template)

```html
<img src="{{itemImageUrl}}" [style.display]="displayNone">
	<span [style.text-decoration]="lineThrough">{{ item.name }} </span>
<button (click)="delete()">Delete</button>
```



src/app/item-detail/item-detail.component.ts (deleteRequest)

```ts
// This component makes a request but it can't actually delete a hero. 
@Output() deleteRequest = new EventEmitter<Item>();
delete() {
  this.deleteRequest.emit(this.item);
  this.displayNone = this.displayNone ? '' : 'none';
  this.lineThrough = this.lineThrough ? '' : 'line-through';
}
```





组件定义了 `deleteRequest` 属性，它是 `EventEmitter` 实例。 当用户点击*删除*时，组件会调用 `delete()` 方法，让 `EventEmitter` 发出一个 `Item` 对象。

现在，假设有个宿主的父组件，它绑定了 `ItemDetailComponent` 的 `deleteRequest` 事件。

src/app/app.component.html (event-binding-to-component)`content_copy<app-item-detail (deleteRequest)="deleteItem($event)" [item]="currentItem"></app-item-detail>`

当 `deleteRequest` 事件触发时，Angular 调用父组件的 `deleteItem` 方法， 在 `$event` 变量中传入*要删除的英雄*（来自 `ItemDetail`）。



## 双向绑定

双向绑定是通过方括号里面套一个圆括号来做的，模板写法：

```html
<font-resizer [(size)]="fontSizePx"></font-resizer>
```

对应组件内部的属性定义：

```ts
public fontSizePx:number=14;
```

## 结构型指令

### *ngIf

```html
<p *ngIf="isShow" style="background-color:#ff3300">显示还是不显示？</p><button class="btn btn-success" (click)="toggleShow()">控制显示隐藏</button>
```

```ts
public isShow:boolean = true;
public toggleShow():void{
  this.isShow = !this.isShow;
 }
```

### *ngFor

```html
<li *ngFor="let hero of heroes;">
  
<li *ngFor="let race of races;let i=index;">    {{i+1}}-{{race.name}}</li>

<li *ngFor="let user of users; index as i; first as isFirst">
```

- `$implicit: T`：迭代目标（绑定到`ngForOf`）中每个条目的值。
- `ngForOf: NgIterable<T>`：迭代表达式的值。当表达式不局限于访问某个属性时，这会非常有用，比如在使用 `async` 管道时（`userStreams | async`）。
- `index: number`：可迭代对象中当前条目的索引。
- `count: number`：可迭代对象的长度。
- `first: boolean`：如果当前条目是可迭代对象中的第一个条目则为 `true`。
- `last: boolean`：如果当前条目是可迭代对象中的最后一个条目则为 `true`。
- `even: boolean`：如果当前条目在可迭代对象中的索引号为偶数则为 `true`。
- `odd: boolean`：如果当前条目在可迭代对象中的索引号为奇数则为 `true`。

#### 带 `trackBy` 的 `*ngFor`

如果将 `NgFor` 与大型列表一起使用，则对某个条目的较小更改（例如删除或添加一项）就会触发一系列 DOM 操作。 例如，重新查询服务器可能会重置包含所有新条目对象的列表，即使先前已显示这些条目也是如此。在这种情况下，Angular 只能看到由新的对象引用组成的新列表，它别无选择，只能用所有新的 DOM 元素替换旧的 DOM 元素。

你可以使用 `trackBy` 来让它更加高效。向该组件添加一个方法，该方法返回 `NgFor` 应该跟踪的值。这个例子中，该值是英雄的 `id`。如果 `id` 已经被渲染，Angular 就会跟踪它，而不会重新向服务器查询相同的 `id`。

src/app/app.component.ts`content_copytrackByItems(index: number, item: Item): number { return item.id; }`

在微语法表达式中，将 `trackBy` 设置为 `trackByItems()` 方法。

src/app/app.component.html`content_copy<div *ngFor="let item of items; trackBy: trackByItems">  ({{item.id}}) {{item.name}} </div>`

这就是 `trackBy` 效果的说明。“Reset items” 将创建具有相同 `item.id` 的新条目。“Change ids” 将使用新的 `item.id` 创建新条目。

- 如果没有 `trackBy`，这些按钮都会触发完全的 DOM 元素替换。
- 有了 `trackBy`，则只有修改了 `id` 的按钮才会触发元素替换。





```ts
public races:Array<any>=[    {name:"人族"},    {name:"虫族"},    {name:"神族"}];
```

*ngSwitch 代码实例：

<div [ngSwitch]="mapStatus">    <p *ngSwitchCase="0">下载中...</p>    <p *ngSwitchCase="1">正在读取...</p>    <p *ngSwitchDefault>系统繁忙...</p></div>

public mapStatus:number=1;