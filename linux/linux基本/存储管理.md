显示当前分区情况
fdisk -l

## 磁盘挂载与卸载

+ 单一文件系统不应该被重复挂载在不同的挂载点(目录)中；
+ 单一目录不应该重复挂载多个文件系统；
+ 要作为挂载点的目录，理论上应该都是空目录才是。

如果你要用来挂载的目录里面并不是空的，那么挂载了文件系统之后，原目录下的东西就会暂时的消失。 举个例子来说，假设你的 /home 原本与根目录 (/) 在同一个文件系统中，底下原本就有 /home/test 与 /home/vbird 两个目录。然后你想要加入新的硬盘，并且直接挂载 /home 底下，那么当你挂载上新的分割槽时，则 /home 目录显示的是新分割槽内的数据，至于原先的 test 与 vbird 这两个目录就会暂时的被隐藏掉了！注意：并不是被覆盖掉， 而是暂时的隐藏了起来，等到新分割槽被卸除之后，则 /home 原本的内容就会再次的跑出来啦！

格式：

`$ mount [-t 文件系统]  [-o 额外选项]  装置文件名  挂载点`

    参数：

    选项与参数：
    -a  ：依照配置文件 /etc/fstab 的数据将所有未挂载的磁盘都挂载上来
    -l  ：单纯的输入 mount 会显示目前挂载的信息。加上 -l 可增列 Label 名称！
    -t  ：与 mkfs 的选项非常类似的，可以加上文件系统种类来指定欲挂载的类型。
          常见的 Linux 支持类型有：ext2, ext3, vfat, reiserfs, iso9660(光盘格式),
          nfs, cifs, smbfs(此三种为网络文件系统类型)
    -n  ：在默认的情况下，系统会将实际挂载的情况实时写入 /etc/mtab 中，以利其他程序
          的运行。但在某些情况下(例如单人维护模式)为了避免问题，会刻意不写入。
          此时就得要使用这个 -n 的选项了。
    -L  ：系统除了利用装置文件名 (例如 /dev/hdc6) 之外，还可以利用文件系统的标头名称
          (Label)来进行挂载。最好为你的文件系统取一个独一无二的名称吧！
    -o  ：后面可以接一些挂载时额外加上的参数！比方说账号、密码、读写权限等：
        rw           读写
        ro           只读
        suid         支持suid
        dev          支持设备文件
        nodev        不支持设备文件
        noexec       不允许执行二进制文件
        exec         允许执行二进制文件
        auto         mount -a 开机自动挂载
        noauto       mount -a 开机不自动挂载
        async        异步写入
        sync         同步同入
        noatime      不更新访问时间atime
        usrquota     支持用户级磁盘配额功能
        grpquota     支持组级磁盘配额功能
        acl          支持acl功能
        remount      在线重新挂载
        pri          指定优先级

示例

`$ mount -t ext4 -o acl /dev/sdb1 /mnt/disk1`
文件系统类型：ext4,xfs,nfs,cifs,iso9660,loop

## 挂载IOS文件

`$  mount -o loop /data/CentOS-7.3-x86_64-DVD-1611.iso /ios/`
`$  df -h`

    文件系统                 容量  已用  可用 已用% 挂载点
    /dev/mapper/centos-root  202G   34G  169G   17% /
    devtmpfs                 1.7G     0  1.7G    0% /dev
    tmpfs                    1.8G   12M  1.7G    1% /dev/shm
    tmpfs                    1.8G   26M  1.7G    2% /run
    tmpfs                    1.8G     0  1.8G    0% /sys/fs/cgroup
    /dev/sda1                794M  179M  616M   23% /boot
    /dev/mapper/centos-opt   200G   85M  200G    1% /opt
    /dev/mapper/centos-home   51G   37M   51G    1% /home
    tmpfs                    349M   36K  349M    1% /run/user/0
    /dev/loop0               4.1G  4.1G     0  100% /ios


## 磁盘分区示例

分区步骤：

    1、需要有一块硬盘
    2、使用分区工具对硬盘进行分区（fdisk）
    3、格式化分区
    4、挂载使用

    进入分区表 新建分区
    更新分区表（刷新分区表）
    格式化
    挂载

第1步：我们首先使用fdisk命令来尝试管理/dev/vdb硬盘设备。在看到提示信息后输入参数p来查看硬盘设备内已有的分区信息，其中包括了硬盘的容量大小、扇区个数等信息：
复制代码

`$ fdisk /dev/vdb`
欢迎使用 fdisk (util-linux 2.23.2)。

更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。

Device does not contain a recognized partition table
使用磁盘标识符 0xf24ceedc 创建新的 DOS 磁盘标签。

命令(输入 m 获取帮助)：`p`

磁盘 /dev/vdb：21.5 GB, 21474836480 字节，41943040 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0xf24ceedc

   设备 Boot      Start         End      Blocks   Id  System

命令(输入 m 获取帮助)：


第2步：输入参数n尝试添加新的分区。系统会要求您是选择继续输入参数p来创建主分区，还是输入参数e来创建扩展分区。这里输入参数p来创建一个主分区：

命令(输入 m 获取帮助)：`n`
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p

第3步：在确认创建一个主分区后，系统要求您先输入主分区的编号。我们在前文得知，主分区的编号范围是1～4，因此这里输入默认的1就可以了。接下来系统会提示定义起始的扇区位置，这不需要改动，我们敲击回车键保留默认设置即可，系统会自动计算出最靠前的空闲扇区的位置。最后，系统会要求定义分区的结束扇区位置，这其实就是要去定义整个分区的大小是多少。我们不用去计算扇区的个数，只需要输入+2G即可创建出一个容量为2GB的硬盘分区。

分区号 (1-4，默认 1)：1
起始 扇区 (2048-41943039，默认为 2048)：此处敲击回车
将使用默认值 2048
Last 扇区, +扇区 or +size{K,M,G} (2048-41943039，默认为 41943039)：`+2G`
分区 1 已设置为 Linux 类型，大小设为 2 GiB

第4步：再次使用参数p来查看硬盘设备中的分区信息。果然就能看到一个名称为/dev/vdb1、起始扇区位置为2048、结束扇区位置为4196351的主分区了。这时候千万不要直接关闭窗口，而应该敲击参数`w`后回车，这样分区信息才是真正的写入成功啦。


命令(输入 m 获取帮助)：`p`

磁盘 /dev/vdb：21.5 GB, 21474836480 字节，41943040 个扇区
Units = 扇区 of 1 * 512 = 512 bytes
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0xf24ceedc

   设备 Boot      Start         End      Blocks   Id  System
/dev/vdb1            2048     4196351     2097152   83  Linux

命令(输入 m 获取帮助)：`w`
The partition table has been altered!

Calling ioctl() to re-read partition table.
正在同步磁盘。

第5步：在上述步骤执行完毕之后，Linux系统会自动把这个硬盘主分区抽象成/dev/vdb1设备文件。我们可以使用file命令查看该文件的属性，有些时候系统并没有自动把分区信息同步给Linux内核，而且这种情况似乎还比较常见（但不能算作是严重的bug）。我们可以输入partprobe命令手动将分区信息同步到内核，而且一般推荐连续两次执行该命令，效果会更好。如果使用这个命令都无法解决问题，那么就重启计算机吧，这个杀手锏百试百灵，一定会有用的。

`$  partprobe`
`$  partprobe`
`$  file /dev/vdb1` 
/dev/vdb1: block special

第6步：格式化，如果硬件存储设备没有进行格式化，则Linux系统无法得知怎么在其上写入数据。因此，在对存储设备进行分区后还需要进行格式化操作。在Linux系统中用于格式化操作的命令是mkfs。这条命令很有意思，因为在Shell终端中输入mkfs名后再敲击两下用于补齐命令的Tab键，会有如下所示的效果

`$  mkfs`
mkfs         mkfs.cramfs  mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.xfs     
mkfs.btrfs   mkfs.ext2    mkfs.ext4    mkfs.minix   mkfs.vfat 

对！这个mkfs命令很贴心地把常用的文件系统名称用后缀的方式保存成了多个命令文件，用起来也非常简单—mkfs.文件类型名称。例如要格式分区为XFS的文件系统，则命令应为mkfs.xfs /dev/sdb1。

`$  mkfs.xfs /dev/vdb1` 
meta-data=/dev/vdb1              isize=512    agcount=4, agsize=131072 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=524288, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0


第7步：挂载，完成了存储设备的分区和格式化操作，接下来就是要来挂载并使用存储设备了。与之相关的步骤也非常简单：首先是创建一个用于挂载设备的挂载点目录；然后使用mount命令将存储设备与挂载点进行关联；最后使用df -h命令来查看挂载状态和硬盘使用量信息。


`$  mkdir /newFS`
`$  mount /dev/vdb1 /newFS/`
`$  df -h`
文件系统             容量  已用  可用 已用% 挂载点
/dev/mapper/cl-root  9.1G  3.7G  5.4G   41% /
devtmpfs             481M     0  481M    0% /dev
tmpfs                497M  124K  497M    1% /dev/shm
tmpfs                497M   14M  484M    3% /run
tmpfs                497M     0  497M    0% /sys/fs/cgroup
/dev/vda1            497M  166M  332M   34% /boot
tmpfs                100M  8.0K  100M    1% /run/user/42
tmpfs                100M   16K  100M    1% /run/user/0
/dev/vdb1            2.0G   33M  2.0G    2% /newFS

开机自动挂载，通过UUID挂载，blkid  查看设备的UUID

`$  blkid /dev/vdb1`
/dev/vdb1: UUID="a9c72628-f6b1-4feb-bdfb-9fa456d119bb" TYPE="xfs"
`$  vim /etc/fstab`
UUID=a9c72628-f6b1-4feb-bdfb-9fa456d119bb  /newFS         xfs     defaults        0 0


